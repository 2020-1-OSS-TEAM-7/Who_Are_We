---
   title : "Wha Are 구경현?" 

   categories : 
       구경현
   
   description : "구경현은 누구인가?"

   toc : True

   toc_label : "목차"

   tags : 
       who_are_we?

   last_modified_at : 2020-06-30

---

# **_Who Are 구경현?_**
![](https://postfiles.pstatic.net/MjAyMDA2MzBfMjQ1/MDAxNTkzNTE0MzQ3NDI4.DLx9HOywZN80B9kYjNnJMjPofnGOmP4Dioz6vOyWwU8g.sckJHulMiHN4OKmAMpEBqHXproj8oXNjj4aTA4euQ2sg.JPEG.dbrudghk69/KakaoTalk_20200628_234728712.jpg?type=w773)
<br/>
student of AI Software Engineering <br/>
<br/>
<br/>
<br/>

### 철학

> 이미 엎질러진 물에 대해서 슬퍼하지 말자. **엎질를 물이 더많이 남아있으니**

### 소개

* Github : [https://github.com/Kookyunghyun](https://github.com/Kookyunghyun)
* Mail : dbrudghk69@naver.com
* Mail2 : dbrudghk690@gamil.com

### Prim algorithm in Data structure

* Python 으로 Prim 알고리즘 구현

```python
# -*- coding: utf-8 -*-
"""prim.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/119zt5Y_TZ2pHe-gpVHLxjQzthgVln1N2
"""

import sys

class Node:
    index = 0
    
    def __init__(self, data):
        self.index = Node.index
        Node.index += 1
        self.data = data
        self.neighbors = []
        
        self.key = sys.maxsize
        self.memo = None
        self.is_done = False
        
    def get_index(self):
        return self.index

    def get_data(self):
        return self.data

    def get_neighbors(self):
        return self.neighbors

    def get_key(self):
        return self.key
  
    def get_memo(self):
        return self.memo

    def get_is_done(self):
        return self.is_done

    def add_neighbor(self, neighbor):
        self.neighbors.append(neighbor)

    def set_key(self, key, memo):
        if(self.key > key):
            self.key = key
            self.memo = memo

    def set_is_done(self):
        self.is_done = True

class Graph:

    def __init__(self, nodes, matrix):
        self.nodes = nodes
        self.matrix = matrix


    def execute_prim(self):
        node = self.nodes[0]
        self.ABC(node)
        self.print_result()
        
    def ABC(self,node):
        matrix = self.matrix[self.get_position(node)]
        neighbor = node.get_neighbors()
        neighbor_position = []
        
        if node.get_is_done():
            pass
        
        else:
            node.set_is_done()
            
            for i in neighbor:
                neighbor_position.append(self.get_position(i))
            
            for j in range(len(neighbor)):
                if not neighbor[j].get_is_done():
                    if neighbor[j].get_key() > matrix[neighbor_position[j]]:
                        neighbor[j].set_key(matrix[neighbor_position[j]],node)
                        
            for k in neighbor:
                for l in self.nodes:
                    if l.get_key() > k.get_key():
                        self.ABC(k)
       
    def get_position(self,node):
        for i in range(len(self.nodes)):
            if node == self.nodes[i]:
                return i
                               
    def print_result(self):
        for node in self.nodes:
            if node.get_memo() is not None:
                print( node.get_data() + ' - ' + node.get_memo().get_data() +' (' + str(node.get_key()) + ')')
    

# ㅁ
dataset = []
for i in range(65, 74):
    dataset.append(chr(i))

# create nodes
nodes = []
for data in dataset:
    nodes.append(Node(data))

# create matrix for weights
matrix = [[0, 4, 0, 0, 0, 0, 0, 8, 0], # w.r.t node A
          [4, 0, 8, 0, 0, 0, 0, 11, 0], # w.r.t node B
          [0, 8, 0, 7, 0, 4, 0, 0, 2], # w.r.t node C
          [0, 0, 7, 0, 9, 14, 0, 0, 0], # w.r.t node D
          [0, 0, 0, 9, 0, 10, 0, 0, 0], # w.r.t node E
          [0, 0, 4, 14, 10, 0, 2, 0, 0], # w.r.t node F
          [0, 0, 0, 0, 0, 2, 0, 1, 6], # w.r.t node G
          [8, 11, 0, 0, 0, 0, 1, 0, 7], # w.r.t node H
          [0, 0, 2, 0, 0, 0, 6, 7, 0]] # w.r.t node I

# set neighbor relation
for i in range(0, len(nodes)):
    for j in range(i+1, len(nodes)):
        if matrix[i][j] > 0:
            nodes[i].add_neighbor(nodes[j])
            nodes[j].add_neighbor(nodes[i])

# create a graph
graph = Graph(nodes, matrix)

# execute prim algorithm
graph.execute_prim()
```


### 경력

|  | 기간  | 담당업무 |
| :---------:|:---------:|:---------:|
| ![](http://post.phinf.naver.net/MjAxNzA5MDRfOTkg/MDAxNTA0NTE5MjQxOTI1.BAAaMGoRjWPnRfcOgvdw3l5x_Aju_htKMES54NI3l4Eg.QkFLCekzjSo7NLtr28SwVu7igFv7SK7WPQx4-ci0MWYg.JPEG/I2kCckLViWGX7Opx5iaMd1uSybfs.jpg)<br/> Nexon | 2017.08.23 ~ 2018.10.08    | 2017 넥슨 프레임워크 개발  |
| ![](http://blogfiles.naver.net/MjAyMDAyMjdfNTEg/MDAxNTgyODExNDAyNjU1.TLyoqJ0uqcadGLM_tjgbGWmDWIuVNWIXYGb9rPTA4MMg.9Snx34gq4CF0vZs_KAxlu7FFeE0BKf8FEQyeaWSpupQg.JPEG.wanja-2590/%B7%A3%B4%FD%B4%D9%C0%CC%BD%BA_%C7%F9%B5%BF%B5%A6_%B5%A5%C0%FC%B5%A6_%C0%C7%BF%DC%B7%CE_%B8%F0%B8%A3%B4%C2_%B2%DC%C6%C11.jpg)<br/> Random dice |  2015.08.02 ~ 2017.6.25   |  랜덤 다이스 게임 엔진 개발  |
| ![](http://imgnews.naver.net/image/112/2014/03/24/20140324000854_0_59_20140324110704.jpg)<br/> Google  | 2023.01.01 ~ |  Google 시스템 아키텍쳐 |

